# JavaScript 내장 객체
## Object 객체
내장 객체(Built-in Object)는 브라우저의 JS 엔진에 내장된 객체를 의미함. 모든 Object 객체는 모든 JS의 루트 객체.

String, Number, Date, Array, Math, etc... ch02_js_object / 01_js_methods.html / .js 참조

## String 객체
문자열을 다루는 property / 함수를 제공

1. length
```js
let txt = 'abcd';
let txtLength = txt.length;
console.log('문자열의 길이는 ' + txtLength + '입니다'.);
```

2. indexOf()
문자열 안에 특정 문자열이 존재하는지를 찾고 문자열이 시작되는 index를 반환하는 method.
- 문자열을 찾지 못하면 -1를 return

3. lastIndexOf()
다 비슷한데 찾고자 하는 문자열이 둘 이상 반복되면 제일 마지막에 발견된 문자열의 index를 return.
- 문자열을 찾지 못하면 -1를 return

4. slice()
매개변수로 시작 위치 / 종료 위치를 줬을 때 문자열의 해당 부분을 잘라내서 return하는 method 

5. substring()
- slice()랑 다 똑같은데 마이너스 인덱스가 없다.

6. substr()
- slice() 랑 비슷한데 두 번째 매개변수가 한계값 미만을 지시하는게 아니라 첫 번째 매개변수로부터의 문자 개수를 의미한다. 
- 얘는 마이너스 인덱스가 또 있다.

7. replace()
- 문자열 내의 특정 문자열을 지정한 문자열로 바꾸는 함수
- 마치 vs code 상에서 ctrl + r 누르면 문자열 검색해서 바꿀 수 있는 거랑 동일한 기능이다.

- 정규식과 조합했을 때 다양하게 replace() 적용이 가능하다.
  - `/i` : insensitive - 대소문자 구분 안함
  - `/g` : global - 일치하는 문자열 전체 replace() 적용 

8. toUpperCase(), toLowerCase()
9. concat()
- 두 개 이상의 문자열을 하나의 문자열로 합치는 method 
10. trim()
- 문자열 앞/뒤 공백을 모두 제거하는 함수 
- DB에 공백이 있으면 조회할 때 실패하는 경우가 있어 공백 제거하고 조회하는 일이 많다.

11. charAt()
- 문자열에서 특정 인덱스에 해당하는 문자 하나를 반환하는 method 

12. charCodeAt()
- 문자열에서 특정 인덱스에 해당하는 문자의 _유니 코드_ 값을 반환

13. split()
- 문자열 내의 특정 기준을 가지고 문자열을 분리하여 _배열_ 로 반환하는 method 

14. startsWith(), endsWith()
- 문자열의 시작 혹은 끝이 매개변수로 전달된 값으로 이뤄져있는지 확인하는 method

- return type boolean 이다.

  - 실무 사례
    startsWith('https')를 해서 보안이 뛰어난 https로 접속했는지를 확인한다. 이상의 경우 false가 나오게 되면 http로 접속했다는 뜻이 됨. 
    endsWith()의 경우엔 특정 파일 확장자인지를 체크하는 용도로 쓰인다.
    endsWith('.pdf'); 와 같은 방식이다.

## Number 객체

1. toString() - 설명 생략
2. toFixed()
- 소수점 몇 번 째 자리까지 보여줄지를 결정하는 method
- 매개변수로 소수점 자리수 사용
- 반올림 적용 

3. toPrecision()
- 2번과 다르게 정수와 소수를 포함해서 몇 번째 자리까지 보여줄지 결정하는 method

4. parseInt()
- 전역 함수로 정수로 반환.
문자열의 시작이 number면 number로 반환 

5. parseFloat()
- 전역 함수로 부동소수점으로 반환

## Array 객체
03_js_array_method.html

1. toString()
- 배열 내에 element들을 ',' 기준으로 모두 결합해 하나의 문자열로 return 

2. join()
- 배열 내의 모든 문자를 매개변수로 지정한 문자를 이용해 element들을 구분함.
`배열명.join('/')` 라고 가정했을 경우 
결과값은
요소1 / 요소2 / 요소3... 으로 / 기준으로 결합됨. 

3. pop()
- 배열에서 마지막 데이터를 제거하고 마지막 데이터를 return 

4. push()
- Java Collection에서 list / set에서 .add()와 같다. 어제 했다.

5. shift()
- pop()과 달리 첫 번째 element를 제거하고 그 element를 return

6. unshift()
- 배열의 맨 앞에 element를 추가하고 배열의 index를 return

- 굳이 맨 앞에 추가하는 method가 따로 있는 실무 사례
  - HTML 문서 작성 시에 `<select>` 태그 구현할 때. 예를 들어서 DB에서 지역 목록 가져오고 가져온 지역 목록을 `<select>` 태그의 `<option>` xormfh cnrkgkfurh gkf Eo `<select>` 태그에서 사용자에게 제일 먼저 보이는 옵션이 '선택하세요' 와 같은 정보성 글이다. 이럴 때 DB에서 '선택하세요' 가 있지 않을테니까 unshift('지역을 선택하세요'); 로 배열에 추가하는 방식이 있다.
  - 혹시 헷갈리면 html_css 파일에서 ctrl + shift + f 'select' 검색 해봐.

7. 배열 element 변경
```js
let subs = ['국어', '수학', '영어', '자바', '자바스크립트'];
sub[0] = '파이썬';
```

8. splice()
- 새로운 element를 특정 위치에 추가하는데 기존 element를 삭제도 가능.
```js
// splice()
let fruits2 = ['Banana', 'Orange', 'Apple', 'Mango'];
fruits2.splice(2, 0, 'Lemon', 'Kiwi');
console.log(fruits2);
// 결과값 : ['Banana', 'Orange', 'Lemon', 'Kiwi', 'Apple', 'Mango']
```
splice(2, 0, 'Lemon', 'Kiwi')의 매개변수 목록

1. 2 - 새로운 element를 추가할 인덱스 넘버
2. 0 - 첫 번째 매개변수에 해당하는 인덱스에서 element를 추가하기 _전_ 에 삭제할 element 수
  - 우린 0으로 지정했으니 아무것도 삭제되지 않았다. 
3. 'Lemon', 'Kiwi', ... etc - 나머지 매개변수는 추가할 element들에 해당함.

9. concat()
- 2개 이상의 배열을 하나의 배열로 결합

10. slice()
- String에서와 동일
- 근데 배열 형태로 return

11. sort() -> 오름차순 정렬이다.
12. reverse() -> 내림차순 정렬이다.
  - Java처럼 골아프게 안해도 된다.

13. filter()
- 배열에서 특정 조건을 만족하는 배열의 element만을 찾아서 _새로운 배열_ 로 return한다.

- 배열 다룰 때 제일 많이 쓰고 프론트엔드에서도 자주 사용하는 method

- 특정 조건을 만족하는 데이터만 추출해내는 프로그램을 작성하는 경우가 빈번한데 이때 filter()를 쓰기 때문에 필수적이라고 할 수 있다.

형식 
`배열명.filter(콜백함수([, index[, 배열]])[, thisArg])`

filter() method엔 특정 조건을 체크하는 callback 함수를 매개변수로 전달한다. 

여기서의 callback 함수는 배열의 각 element를 시험할 함수에 해당한다. 시험을 통과(true)하게 되면 element를 그대로 유지하고 false라면 버리게 된다. 즉 true인 element들만 모아서 
_새로운 배열_ 을 생성한다.

callback 함수의 매개변수는 
  - element - 처리할 현재 element(기존 배열의 element를 의미한다)
  - index(optional) - 처리할 현재 element의 인덱스
  - array(optional) - 배열 전체 

```js
/* 
  filter()메서드를 활용해 words 배열 내에 있는 단어의 길이가 6 이상인 애들만 추출해서 새로운 배열을 만들어 console에 출력하도록 하겠다.
*/
let words = ['부산광역시', '부산시', '서울특별시', '서울', '경상남도 김해시', '남해시', '광주광역시', '경기도 광주시', '오사카부 오사카시', '오사카'];

let result = words.filter(function(word) {
  return word.length > 4;
});

console.log(result);
// 결과값 : ['부산광역시', '서울특별시', '경상남도 김해시', '광주광역시', '경기도 광주시', '오사카부 오사카시']
```

14. map()
- 배열 내의 element가 object일 때 배열에 담긴 object를 _새로운 형태의 object_ 로 반환하여 배열로 return

15. reduce()
- 배열에 담긴 element를 하나씩 순회하며 callback 함수의 실행값을 _누적_ 하여 return하는 method. 누적 결과 값은 숫자, 문자, 객체 모두 가능.

- 주로 배열 내의 element 데이터의 합계를 구할 때 많이 사용됨.

- 배열 내의 element가 객체인 경우 누적 값을 구하고자 하는 object의 property를 참조해서 쓴다.(persons라면 persons[0].score가 되겠네.)

```js
// reduce()
let scores = [40, 100, 1, 5, 25, 10];
let sum = scores.reduce(
  function(total, currentValue) {
    return total + currentValue;
  }
);

console.log(sum); // 결과값 : 181
```
reduce() method 내의 callback 함수는 4개의 매개변수를 가질 수 있다. (주로 2개만 쓰고 나머지는 optional 이다.)

- 1번 매개변수 : accumlator(누적값 - 우린 total 썼다.) 
- 2번 매개변수 : currentValue(배열의 현재 element 우린 currentValue)
- 3번 매개변수 : currentIndex(현재 index 넘버)
- 4번 매개변수 : arr(배열)

## Set 객체

1. Set 생성자
```js
let mySet = new Set();
```

2. add() - Java와 같다.
3. has() - 특정 데이터가 있는지 확인한다. return boolean 
4. delete() - 특정 데이터를 삭제한다.
5. clear() - 저장되있는 모든 데이터를 삭제한다. 
6. forEach() - set에 저장된 모든 데이터를 읽어온다.
```js
mySet.forEach(function(item) {
  console.log(item);
});
```

## Map 객체
```js
let userMap = new Map();
```
2. set() - Map 객체에 데이터 저장할 때 쓰는거다. Java에서의 맵이름.put("키", "값"); 과 동일
3. get() - Java에서의 맵이름.get("키"); 와 동일
4. has() - 특정 키의 값이 저장돼있는지 확인 return boolean
5. delete() - 특정 데이터를 삭제
  userMap.delet("name");
6. clear() - 저장돼있는 모든 데이터 삭제 
7. forEach() - 저장돼있는 모든 데이터 읽기
```js 
userMap.forEach(function(item) {
  console.log(item);
});
```

### JavaScript Object vs. JavaScript Map

1. Object는 key를 string으로만 지정해야 하지만 Map은 다른 타입도 가능하다.
2. Object는 몇 개의 데이터가 담겼는지 수동 계산해야하지만 Map은 맵이름.size 로 크기를 알 수 있다.
3. Object는 저장된 데이터를 for-in(어제 수업)으로 읽었을 때 순서를 보장하지 않지만 Map은 데이터를 저장한 순서대로 읽어온다. (근데 Java Map은 또 순서를 보장하지 않는다.) 

## JSON 객체 

- 데이터를 저장하거나 전송할 때 많이 사용되는 _경량_ 의 데이터 교환 형식이다.

- 다수의 플랫폼에 사용됨.
  
  1. 서버와 클라이언트 간의 데이터 전송 시 많이 사용
  2. JavaScript의 Object 객체 표기법과 매우 _유사_
  3. JSON 데이터는 JavaScript JSON 객체의 parse() method를 이용하면 JavaScript Object 객체로 변환하여 사용가능
  4. 프로그래밍 언어와 상관없이 사용할 수 있는 _데이터 교환 형식_ 
  5. 대부분의 언어에서 JSON 데이터를 처리할 수 있는 라이브러리 제공(Java는 GSON이였다.)

### 중요 내장 함수 목록
1. JSON.stringify(Object명) - 데이터를 서버로 전송하기 위해 데이터 형태를 문자열로 변환(이유 :가벼워서) 해준다. 여기선 JavaScript 객체를 문자열로 변환해준다.

2. JSON.parse(JSON명) - 서버로부터 응답받은 JSON 데이터를 JavaScript Object의 객체로 변환해준다.

## Window 객체 
05_js_window.html
window 객체는 전역(global) 객체다. 현재는 브라우저라고 생각해도 무방하다.

1. alert() - 윈도우 화면에 경고 메시지를 출력 
2. confirm() - return type boolean

```js
if (confirm('정말 삭제하시겠습니까?')) {
  // 삭제 로직
  console.log('삭제');
}
```

3. prompt() - 문자열을 입력받을 수 있는 함수
```js
let txt = prompt('비밀번호를 입력하세요');

if (txt === null) {
  // 취소 버튼을 눌렀을 때의 로직
} else if (txt === '') {
  // 아무 값도 입력하지 않고 확인 버튼 눌렀을 때의 로직 
} else if (txt !== '') {
  // 어떤 값을 입력하고 확인 버튼을 눌렀을 때.
  // 그럼 여기에 비밀번호 일치 했을 때와 아닐 때의 조건문이 추가로 들어가야겠다.
} 
```
4. open() - 윈도우 새창 / 새 탭으로 지정한 url을 오픈하는 함수 

5. seTimeout() / clearTimeout()
  - seTimeout() 함수는 두 번째 매개변수로 지정한 시간 간격 이후에 첫 번째 매개변수에 정의한 함수를 실행시킴. callback 개념을 알아야 써먹을 수 있다.

  - clearTimeout() - seTimeout() 함수에서 정의한 함수가 실행되지 않았을 때, seTimeout()의 콜백 함수를 실행시키는 것을 중지할 때 사용.

  - 밀리초 사용한다.

# JavaScript 고급 문법(이지만 front에서 그냥 다 쓰는)

## Default Function Parameter
- 함수를 호출할 때 예를 들어 `function(message) {return 어쩌고};` message가 비어있는 상태가 되면 호출 단계에서 argument가 없기 때문에 오류(undefined)가 발생한다. 만약에 매개변수가 함수 내에서 특정 기능을 구현하기 위해서 반드시 요구된다면 _아무런 값이 없을 경우_ 함수를 호출할 때마다 체크를 해야한다. 
```js
function say(message) {
  if (message !== undefined) {
    console.log(message);
  } else {
    console.log('매개변수가 입력되지 않았습니다.');
  }
}
say();    // argument 없이 함수를 호출했을 경우엔
// 결과값 : 매개변수가 입력되지 않았습니다.
```
Default function parameter를 지정하게 되면 argument없이 함수를 호출했을 때 미리 설정해둔 기본값으로 함수를 호출해 오류가 발생하지 않게끔 하는 사전 작업

```js
function say(message='매개변수가 입력되지 않았습니다.') {
  console.log(message);
}

say();
```
## Rest Parameter
일반적인 함수 선언식으로 함수에 따라 몇 개의 argument가 요구되는지 미리 선언한다. 매개변수 2 개 짜리로 정의하면 함수 호출 시에 2개의 argument를 요구하고 4개 짜리를 정의하면 함수를 호출할 때 4개의 argument를 요구한다.
근데 우리가 3개 짜리로 쓰고 싶으면 어떻게 해야하나. 이런 문제가 있다.

문제 사례 
```js
function sum(x1, x2) {
  return x1+x2;
}

sum(5, 7);

function sum(x1, x2, x3, x4) {
  return x1+x2+x3+x4;
}

sum(5, 7, 8, 10);
```
하지만 3개 짜리 연산은 불가능해서 sum(1, 2, 3, 0); 같은 꼼수를 써야만 한다.
Rest Parameter의 개념은 몇 개의 매개변수가 전달될지 모르는 상황에서 매우 유용하다.

Rest Parameter 적용 예시
```js
function sum(...args) { // 이렇게 매개변수를 선언하면 함수 호출 시에 매개변수 개수에 상관없이 할당 가능하고 이렇게 할당된 값은 _배열_ 로 저장 된다.
  let total = 0;
  // 배열로 저장되기 때문에 element를 추출하여 합 연산을 해야함.
  for (let x of args) {
    total += x;
  }
  return total;
}

sum(1,2,3);
sum(2,4,56,7,8,8,75645235);
```

## Arrow Function(Lambda Expression의 JS ver.)
기존의 함수 표현 방식들 
1. 함수 선언식
```js 
function hello(name) {
  return 'hello' + name;
}
```
2. 함수 표현식
```js
const hello2 = function(name) {
  return 'hello' + name;
}
```
hoisting 여부로 인해 # 1 , # 2 방법이 생겨났다.

화살표 함수는 함수를 정의하는 비교적 최근 방법이다.(우린 람다에서 배웠지만 여기서 훨씬 많이 써먹는다). 화살표 함수를 사용해서 함수를 정의하면 구문이 짧아진다는 장점이 있다. 단점은 람다에서 봤던 것처럼 너무 복잡한 로직을 구현하긴 힘들다는 점이다.

3. 화살표 함수
```js
// full form 
const hello3 = (name) => {return 'Hello' + name};

// 매개변수가 하나라면 소괄호(())를 생략할 수 있다.
const hello4 = name => {return 'Hello' + name};

// 실행문이 한 줄이라면 return / 중괄호{{}}를 생략할 수 있다.
const hello5 = name => return 'Hello' + name;

// 매개변수가 없다면 빈 소괄호를 사용
const hello6 = () => 'Hello, there';
```
## Template Literals
```js
// 1. 기존 작성 방식
function hello(name) {
  console.log('Hello' + name + '환영합니다.');
}

// 2. 템플릿 리터럴 적용 방식
function hello2(name) {
  console.log(`Hello ${name}. 환영합니다.`);
}
```
2의 장점은 중간에 ++ 기호 넣는다고 오류 발생할 확률이 적단느 점이다.
단점은 대충 보면 얘가 ''인지 ``인지 구분할 방법이 없다는 것이다.
그래서 차라리 중간에 ${}가 있으면 템플릿 리터럴이 적용되었다고 보는게 우리가 정신건강에 좋다. 
01_js_applied.html

## Object Literal Syntax Extension
```js
let fName = 'Josh';
let lName = 'Smith';

let person = {
  fName: fName,    // 앞은 person의 property고 뒤는 415번 라인의 변수다. 
  lName: lName, 
}

// 2. Object Literal
let type = 'student';
let score = {
  [type]: 'Josh',
  score: 92;
}
```
2. 번에서 Object의 key에 []가 있다는 점을 확인할 수 있다. Js 객체의 key를 []로 감싸게 됐을 땐 '할당된 변수 값' 을 의미함.
이상의 장점으론 Js 객체의 key를 _동적으로_ 생성 가능.
## Spread Operator(JS에서 처음 배운다.)
- 배열, 문자열 등 반복가능객체 형태의 데이터를 element 하나하나로 분해해서 사용할 수 있도록 함. 
## Object Destructuring(객체 구조분해)

## Array Destructuring(배열 구조분해)

## JS HTML DOM
ch04_js_dom
- Dom(Document Object Model)
- JS는 HTML 문서의 모든 요소에 접근하여 변경할 수 있다. 간단하겐 `<table>` 태그 내에 `<td>`를 추가할 수 있을거다.

1. 모든 HTML element
2. HTML 태그의 속성(특성)
3. CSS 스타일
4. HTML element 및 속성을 제거
5. 새로운 HTML element 및 속성을 추가
6. 페이지 내에 존재하는 모든 HTML 이벤트에 대한 반응
7. 새로운 HTML 이벤트 추가
## DOM Element 
01_domelement.html

JS에서 HTML element에 대한 다양한 제어를 위해 가장 먼저 할 일은 HTML element에 대한 접근이다. JS상에서 HTML 요소를 찾는 방법은,

1. id 값을 통해
2. 태그명을 통해
3. class 명을 통해
4. CSS의 선택자 개념을 통해 찾을 수 있다.

- HTML element의 id로 찾기
  - HTML 태그의 id 속성은 고유값이기 때문에 단일한 결과가 나온다.
  - 만약에 id가 정확하다면 JS 객체의 형태로 HTML element가 return 
  - 일치하는 id가 없다면 null return
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM element</title>
</head>
<body>
  <input id="userid" type="text">
  <p>태그명을 사용해서 HTML 요소를 찾습니다.
  document.getElementById</p>
  <script>
    let element = document.getElementById('userid');

    console.log(element);
  </script>
</body>
</html>
```

- 태그명을 통한 HTML element 추출
02_js_dom_tag.html

## DOM Attribute
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>태그명을 통한 HTML element</title>
</head>
<body>
  <p>HTML 요소에 대한 접근</p>
  <p>태그명을 사용하여 HTML element를 추출합니다. <br> 
  document.getElementsByTagName('p');
</p>
<script>
  let elements = document.getElementByTagName('p');

  console.log(elements)
</script>
</body>
</html>
```
- id 값을 통한 추출과 태그명을 통한 추출에서의 차이점은 id는 고유값인데 반해 태그는 한 HTML 문서 내에 복수로 있을 수 있으므로 return 타입이 JS 객체 하나짜리가 아니라 JS 객체를 element로 하는 배열이 return된다는 점이다.

- 이를 명확히 확인하기 위해 method 명을 보면
- getElement's'ByTagName 이라고 명시되어있는 점을 알 수 있다.

- 클래스명을 통한 HTML 요소 찾기
- CSS 선택자를 이용한 HTML 요소 찾기 

## HTML 내용 변경
03_js_html.html
1. innerHTML
  - HTML의 특정 위치에 새로운 HTML을 삽입할 때 사용

2. innerText
  - 1과 비슷하지만 텍스트 내용만 삽입 가능.
## DOM event(클릭 이벤트 등)
웹 페이지를 이용하면 웹 화면과 사용자 사이에 상호작용이 나타난다. 예를 들어 
1. 버튼을 클릭한다든지
2. 마우스를 스크롤한다든지
3. 검색을 위해 검색 키워드를 input 창에 입력한다든지 하는 행동 등.
이상의 모든 상호작용을 event라고 한다.

### click 이벤트(onclick) - 골아픈게 react에선 onClick이다.
마우스 좌클릭할 때 발생하는 이벤트다. 검색 / 저장과 같은 버튼을 클릭하면 이때 클릭 이벤트가 발생한다.

대표적인 예 `<button>` 요소에 클릭 이벤트가 일어나는지를 감시하고 클릭 이벤트가 일어나는 순간 특정 함수를 실행시켜야된다.

이때 `<button>` 태그 내의 onclick 속성을 이용하여 처리할 수 있다.

- 검색 버튼을 클릭하면 검색 기능이 실행되어 화면에 검색 결과를 출력
- 저장 버튼을 클릭하면 사용자가 입력한 데이터를 서버로 보내고 DB에 저장 
- 메뉴 버튼을 클릭하면 해당 메뉴로 이동 등

04_click_event.html

### change 이벤트 (onChange)
- 값이 변경되었을 때 발생하는 이벤트
- 대표적으론 `<select>`, `<input type="checkbox">`, `<input type="radio">` 에서 발생한다.

05_change_event.html

### key 이벤트(onkeydown, onkeyup, onkeypress)
key 이벤트는 사용자가 입력창에서(`<input>` 태그에서) 키보드를 입력할 때 발생
사용자가 키를 입력하면 keydown -> keypress -> keyup의 순서로 이뤄짐.

input type="text"에 keydown / keypress / keyup 이벤트를 모두 받을 수 있도록 설정하고 순서를 검증하겠다.

06_key_event.html

현재 상황에서  chorme 자체에서 strictmode로 실행 중이기 때문에 두 번씩 찍혀서 콘솔상에서 명확하게 안보일 수 있지만 입력 시점에서 onkeydown이 일어나고 키를 뗐을 때 onkeyup이 일어나는 것을 볼 수 있다.

# JS 주요 Web APIs

## LocalStorage / SessionStorage 

까지 하고 배운거 응용해서 todo List JS 만들기 해봄.